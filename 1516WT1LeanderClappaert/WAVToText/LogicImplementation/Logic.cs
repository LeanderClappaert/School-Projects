using System;
using System.Collections.Generic;
using DataAccessImplementation;
using DataAccessInterfaces;
using LogicInterfaces;
using System.IO;
using FourierLib;

namespace LogicImplementation
{
    public class Logic : ILogic
    {
        // events
        public event Action<string> CsvError;
        public event Action<string> WavError;

        // connect with database
        private IDataAccess backend = new DataAccess();

        /// <summary>
        /// Check if the choosen file is a wav file
        /// </summary>
        /// <param name="path">Path where wav file is located</param>
        /// <returns>True or false</returns>
        public bool CheckChosenWavFile(string path)
        {
            var extension = Path.GetExtension(path);
            if (!extension.Equals(".wav")) return false;
            else return true;
        }

        /// <summary>
        /// Check if the choosen file is a csv file
        /// </summary>
        /// <param name="path">Path where csv file is located</param>
        /// <returns>True or false</returns>
        public bool CheckChosenCsvFile(string path)
        {
            var extension = Path.GetExtension(path);
            if (!extension.Equals(".csv")) return false;
            else return true;
        }

        /// <summary>
        /// Get the frequencies from the wav file
        /// </summary>
        /// <param name="wavPath">Path where wav file is located</param>
        /// <param name="csvPath">Path where csv file is located</param>
        /// <returns>Integer array with frequencies</returns>
        public int[] GetFrequencies(string wavPath, string csvPath)
        {
            // events
            backend.CsvError += Backend_CsvErrorHandler;
            backend.WavError += Backend_WavErrorHandler;
            // get all the info out of the wav file
            backend.ReadWavFile(wavPath);

            byte[] dataBytes = backend.DataBytes; 
            float[] filteredData = backend.DataToFloat(dataBytes);
            int sampleRate = backend.SampleRate; //44100
            int x = 0; //custom iterator
            int[] frequencies = new int[filteredData.Length / sampleRate];

            for (int i = 0; i < frequencies.Length; i++)
            {
                float[] tempStore = new float[sampleRate];
                for (int y = 0; y < sampleRate; y++)
                {
                    tempStore[y] = filteredData[x+y];
                }

                float[] completeData;
                if (!Fourier.IsPowerOf2(tempStore.Length)) completeData = AdjustCurrentData(tempStore);
                else completeData = new float[1];

                frequencies[i] = CalculateFrequenties(completeData);
                x += sampleRate;
            }

            return frequencies;   
        }

        /// <summary>
        /// Eventhandler for the error generated by the wav section in the backend
        /// </summary>
        /// <param name="error">Error text which will be displayed</param>
        private void Backend_WavErrorHandler(string error)
        {
            WavError(error);
        }

        /// <summary>
        /// Eventhandler for the error generated by the csv section in the backend
        /// </summary>
        /// <param name="error">Error text which will be displayed</param>
        private void Backend_CsvErrorHandler(string error)
        {
            CsvError(error);
        }

        /// <summary>
        /// Get the hidden text by comparing found frequencies with the frequencies listed in the csv file
        /// </summary>
        /// <param name="frequencies">found frequencies</param>
        /// <param name="csvPath">Path where csv file is located</param>
        /// <returns>The hidden text</returns>
        public string GetSecretText(int[] frequencies, string csvPath)
        {
            Dictionary<char, int> csvFile = backend.ReadCsvFile(csvPath);
            string fullText = "";

            for (int i = 0; i < frequencies.Length; i++)
            {
                foreach (var line in csvFile)
                {
                    if (frequencies[i] == line.Value)
                    {
                        fullText += line.Key;
                        break;
                    }
                }
            }

            return fullText;
        }

        /// <summary>
        /// Get the frequencies hidden in the sound signals of the wav file
        /// Source: http://stackoverflow.com/questions/7674877/how-to-get-frequency-from-fft-result
        /// </summary>
        /// <param name="completeData">The data part from the wav file</param>
        private int CalculateFrequenties(float[] completeData)
        {
            Fourier.RFFT(completeData, FourierDirection.Forward); //forward: time to frequency
            int N = completeData.Length;            // size of FFT and sample window
            int sampleRate = backend.SampleRate;
            float[] fft = new float[N * 2];         // FFT complex buffer (interleaved real/imag)
            double[] magnitude = new double[N / 2]; // power spectrum

            //capture audio in data[] buffer;
            //apply window function to data[];
            // copy real input data to complex FFT buffer

            for (int i = 0; i < N - 1; i++)
            {
                fft[2 * i] = completeData[i];
                fft[2 * i + 1] = 0;
            }

            //perform in-place complex - to - complex FFT on fft[] buffer
            // calculate power spectrum (magnitude) values from fft[]
            float re;
            float im;

            for (int i = 0; i < (completeData.Length / 2 - 1); i += 2)
            {
                re = fft[2 * i];
                im = fft[2 * i + 1];
                magnitude[i] = Math.Sqrt(re * re + im * im);
            }

            // find largest peak in power spectrum
            double max_magnitude = 0;
            int max_index = -1;

            for (int i = 0; i < N / 2 - 1; i++)
            {
                if (magnitude[i] > max_magnitude)
                {
                    max_magnitude = magnitude[i];
                    max_index = i;
                }
            }

            // convert index of largest peak to frequency
            int freq = max_index * sampleRate / N;
            // round frequencies
            int temp = freq % 10;
            if (temp >= 5) freq = ((freq / 10) * 10) + 10;
            else if (temp < 5) freq = ((freq / 10) * 10);

            return (freq);
        }

        /// <summary>
        /// In order for Fourier.RFFT to work, filteredData must have a length which is a power of 2 number.
        /// </summary>
        /// <param name="filteredData">Data array which needs to be altered</param>
        /// <returns>New data array with length = power of 2</returns>
        private float[] AdjustCurrentData(float[] filteredData)
        {
            double currentExp = Fourier.Log2(filteredData.Length);
            int newExp = (int)Math.Ceiling(currentExp);
            float[] completeData = new float[(int)Math.Pow(2, newExp)];

            //transfer data from old array to new array.
            for (int i = 0; i < filteredData.Length; i++)
            {
                completeData[i] = filteredData[i];
            }

            //fill up the rest of the array with 0
            for (int i = filteredData.Length; i < completeData.Length; i++)
            {
                completeData[i] = 0;
            }

            return completeData;
        }
    }
}
